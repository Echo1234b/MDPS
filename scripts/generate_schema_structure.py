import re
import os
from pathlib import Path

"""
Script: generate_schema_structure.py

This utility parses the `MDPS SD.md` structure diagram and creates any **missing**
folders / Python modules so that the repository layout mirrors the official
schema.  The script is idempotent – running it multiple times will not overwrite
or modify existing files – it will only create what is missing.

Usage:
    python3 scripts/generate_schema_structure.py [--dry-run]

If `--dry-run` is supplied, the script will **only** print the actions it would
perform without actually touching the filesystem.
"""

import argparse
import sys

SCHEMA_FILE_NAME = "MDPS SD.md"
ROOT_DIR = Path(__file__).resolve().parent.parent  # Project root (two levels up)
SCHEMA_PATH = ROOT_DIR / SCHEMA_FILE_NAME

INDENT_REGEX = re.compile(r"^[\s│]*")  # Leading indentation (spaces or pipes)
LINE_REGEX = re.compile(r"[├└]──\s+(?P<entry>.+)$")  # Capture the entry after the tree symbol
NUMBER_PREFIX_REGEX = re.compile(r"^(\d+\.)+\s*")  # Strip numeric prefixes like 1.1.2 
INVALID_CHARS_REGEX = re.compile(r"[^a-zA-Z0-9_./]")

# Characters / substrings to normalise in path segments
REPLACEMENTS = {
    " & ": "_and_",
    " &": "_and_",
    "& ": "and_",
    "&": "and",
    " ": "_",
}


def normalise_segment(segment: str) -> str:
    """Normalise a single path segment so that it is a valid Python package/file name."""
    seg = segment
    # Apply explicit replacements first
    for _find, _rep in REPLACEMENTS.items():
        seg = seg.replace(_find, _rep)
    # Remove invalid characters
    seg = INVALID_CHARS_REGEX.sub("", seg)
    return seg


def make_init(path: Path, dry_run: bool):
    """Ensure __init__.py exists in the given directory."""
    init_path = path / "__init__.py"
    if init_path.exists():
        return
    if dry_run:
        print(f"Would create: {init_path}")
    else:
        init_path.write_text("\n# Auto-generated by generate_schema_structure.py\n")
        print(f"Created: {init_path}")


def process_schema(dry_run: bool = False):
    if not SCHEMA_PATH.exists():
        print(f"Schema file not found at {SCHEMA_PATH}", file=sys.stderr)
        sys.exit(1)

    stack = [ROOT_DIR]
    previous_indent_len = 0

    with SCHEMA_PATH.open("r", encoding="utf-8") as fp:
        for raw_line in fp:
            # We only process lines containing tree symbols
            if "──" not in raw_line:
                continue
            line = raw_line.rstrip("\n")
            # Identify indentation (number of leading │ and spaces)
            indent_match = INDENT_REGEX.match(line)
            indent_str = indent_match.group(0)
            indent_level = indent_str.count("│") + indent_str.count("    ")

            # Capture the entry after the tree symbol
            m = LINE_REGEX.search(line)
            if not m:
                continue
            entry_raw = m.group("entry")

            # Remove numeric prefix if present
            entry_clean = NUMBER_PREFIX_REGEX.sub("", entry_raw).strip()
            # Split into name and optional trailing comment (after two spaces)
            entry_clean = entry_clean.split("  ")[0].strip()  # remove trailing details

            # Now normalise
            entry_norm = normalise_segment(entry_clean)

            # Update stack depth
            if indent_level >= len(stack):
                # Descend one level (or same level if first entry)
                pass
            else:
                # Pop until we reach correct parent
                stack = stack[: indent_level + 1]

            parent_dir = stack[-1]
            if entry_norm.endswith(".py"):
                file_path = parent_dir / entry_norm
                if not file_path.exists():
                    if dry_run:
                        print(f"Would create: {file_path}")
                    else:
                        file_path.parent.mkdir(parents=True, exist_ok=True)
                        file_path.write_text(
                            f"\n\"\"\"\nAuto-generated file: {entry_norm}\nTODO: Implement logic.\n\"\"\"\n")
                        print(f"Created: {file_path}")
                # Ensure parent package has __init__.py
                make_init(parent_dir, dry_run)
            else:
                # Directory entry
                dir_path = parent_dir / entry_norm
                if not dir_path.exists():
                    if dry_run:
                        print(f"Would create directory: {dir_path}")
                    else:
                        dir_path.mkdir(parents=True)
                        print(f"Created directory: {dir_path}")
                # Ensure package initialisation
                make_init(dir_path, dry_run)
                # Push onto stack for deeper levels
                if indent_level + 1 > len(stack):
                    stack.append(dir_path)
                else:
                    if indent_level + 1 == len(stack):
                        stack[-1] = dir_path
                    else:
                        stack = stack[: indent_level + 1]
                        stack.append(dir_path)


if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="Generate missing folders/files according to MDPS SD.md schema.")
    parser.add_argument("--dry-run", action="store_true", help="Don't actually create files, just print actions.")
    args = parser.parse_args()
    process_schema(dry_run=args.dry_run)